---
title: 'INTE1120 Assessment 1C'
output:
  html_notebook: default
  html_document:
    df_print: paged
  pdf_document: default
---

```{r setup, include=FALSE}
library(pracma)
library(DescTools)
```

## Introduction
This assessment will continue using R for probability calculations. It is highly recommended that you complete the R tutorial content before attempting this assessment.

### Assessment 1C details:
**Type your short answers into the text box and your code into the R notebook pane. For all code answers, run the R code and display the output. Once you have answered all the questions, you should Knit to HTML and use your web browser to print to PDF. You must submit the PDF file in Canvas before the Due Date.**

**If you have questions about the R notebook format, please see the detailed instructions found in Using R Notebooks**

**Full marks will not be awarded unless all working and explanations are shown and that includes R commands and the answer obtained from them.** 

**This assignment is worth 15 marks in total and contributes 15% to your grade.**
**This assignment has 15 questions, each question shows how many marks are allocated immediately after the question - they are not each worth the same amount.** </p>

***

## Probability and random variables

We now consider probability distributions that are generated by a pseudo-random number generator.
To generate an arbitrary distribution $Px$ which obeys $Px[1]>Px[2]>...$ for 30 points we can use the following steps. 

This command generates 30 uniformly distributed random numbers between 0.2 and 0.8.
```{r}
A<-runif(30, min=0.2, max=0.8)
A
```


Now we can use the numbers in vector $A$ to obtain an arbitrary distribution ($Px$) which obeys $Px[1]>Px[2]>...$ as given below. 

The k-th component of $Px$ is the product of the first $k$ members of $A$. We use two functions in the code below `rep()` and `prod()`. Click the code blocks below and read the help output in the pane to the right.  

```{r}
help("rep")
```

```{r}
help("prod")
```

```{r}

Px<-rep(0, times=length(A)) #creating a vector of 0s, of length same as A
Px
for(k in 1:length(Px)){
  Px[k]<-prod(A[1:k])
}

print(paste0("The Px probability distribution is as follows: "))

Px

sum_Px<-sum(Px)
print(paste0("The initial summing of the distribution Px is: ", sum_Px))

Rem_Px<-c(1 - sum_Px)

print(paste0("The difference between the distribution Px and 1 is: ", Rem_Px))

```

<p style="color:blue">
*Question 1:* This is not yet a probability distribution. Why not? What do we need to do to Px to make it a probability distribution? (*Hint: Use the comments in the code chunk below to guide you*) **(0.5 marks)** </p>

<textarea rows="3" cols="123">
Px above is not yet a probability distribution as the sum of Px does not equal 1. The set of Px could be normalised. Each value in Px could be divided by the sum of Px to get the sum of Px equal 1.
</textarea>\


<p style="color:blue">
*Question 2:* Write the code to scale $P(X)$ into a probability distribution **(1 mark)** </p>
```{r}
# Make sure your final probability distribution vector is named Px and check that all entries sum to 1.

for(l in 1:length(Px)){
  Px[l]<-(Px[l]/sum_Px)
}

print("The scaled (normalised) Px probability distribution is as follows:")

Px

# Save variable Px into Px1 for later usage
Px1 <- Px

ReSum_Px<-sum(Px)

print(paste0("The summing of the value Px is now: ", ReSum_Px))

```

Scenario: Now let us assume that we have an encryption system that has a skewed key distribution. Let $X$ be a random variable that indicates the number of guesses before an attacker guesses the secret key and let $Px$ be the probability distribution. $Px[X=1]$ indicates the probability of the attacker guessing the secret key in the first guess, $Px[X=2]$ is the chance of successfully guessing it in the second guess and so on.

<p style="color:blue">
*Question 3:* Compute the quantities for expectation $E(X)$ and variance $Var(X)$ as well as the square root of $Var(X)$ which is the standard deviation of $X$. Write code to display the values of $E(X)$, $Var(X)$ and the standard deviation $SD(X)$. (*Hint: $E(X)$ and $Var(X)$ are defined in Week 4 R Tutorial 2: Testing the guessing strength of keys*). **(1.5 marks)**  </p>

```{r}
#Replace the 0 with the formula to calculate each value

#X<-sample(1:30,1)
#X

X<-c(1:30)
X

Ex<-sum(X*Px)

print(paste0("The expectation value Ex is: ", Ex))

Varx<-sum(((X-Ex)^2* Px))

print(paste0("The variance value VarX is: ", Varx))

SDx<-sqrt(Varx)

print(paste0("The standard deviation value SDx is: ", SDx))

```


<p style="color:blue">
*Question 4:* For the scenario in *Question 3* what is the expected number of guesses before the secret key is broken? **(1 marks)**</p>

<textarea rows="4" cols="123">
The expected number of guesses before the secret key is identified is 3 guesses, in the current execution, as it's the next integer after the expectation value of 2.36 and the key distribution is skewed, in this instance. The first guess as 3.727131e-01, the second 2.515107e-01, the third 1.999708e-01 and so on. The probability of each guess is decreasing, so the first few guesses have the highest probability, with the probability of each guess decreasing over the distribution set.
</textarea>\

<p style="color:blue">
*Question 5:* What would you expect the number of guesses to be if $Px$ was uniformly distributed? **(1.5 marks)**</p>

```{r}
# write your code to define the probability distribution of a uniform distribution and calculate the expected value of X

Px<-rep((1/length(Px)), times=length(X))

print("The variable standard distribution of Px is as follows:")

Px

Ex<-sum(X*Px)

print(paste0("Raw expected number of guesses is: ", Ex))

print(paste0("Real expected number of guesses is: ", round(Ex)))

```

<textarea rows="3" cols="123">
The expected number of guesses is 16 guesses if X were uniformly distributed. This makes sense as we would expect to have a better than 50% chance of guessing the key once we move past the 50% mark (15 being 50% of 30, which is our value of X in this case). %>% 
</textarea>\

<p style="color:blue">
*Question 6:* Which distribution would you consider more secure and why? **(0.5 marks)**</p>

<textarea rows="2" cols="123">
This uniformly distributed set of values would be more secure as the probability of guessing the correct key value is reduced, requiring more guesses to correctly guess the key value.
</textarea>\

***

Now Let us assume that you must redesign the encryption algorithm such that the probability of the number of chances to guess the key successfully is favouring the cryptographer and not the attacker. Your design results in two options. **Option 1** results in a probability distribution $Px_{Perm}$ which is a random permutation of $Px$. **Option 2** is the probability distribution $Px_{Sort}$ which is composed of the elements of $Px$ sorted such that $Px[1]<Px[2]< \cdots <Px[30]$.

<p style="color:blue"> 
*Question 7:* Write appropriate code to generate $Px_{Perm}$. Compute the expected value and standard deviation of the random variable $X$. (*Hint: Check out the randperm function*) **(1 marks)** </p>

```{r}
# write your code for Question 7 here

print("The saved Px version Px1 is:")
Px1

# Generate a random permutation elements from the previous saved vector Px1
Px1_Perm <- randperm(Px1)

print("A random permutation of Px1 (Px_Perm) is:")
Px1_Perm

Ex1<-sum(X*Px1_Perm)

print(paste0("The expectation value Ex of the permutation of Px_Perm is: ", Ex1))

Varx1<-sum(((X-Ex1)^2* Px1_Perm))

print(paste0("The variance value VarX of the permutation of Px_Perm is: ", Varx1))

SDx1<-sqrt(Varx1)

print(paste0("The standard deviation value SDx of the permutation of Px_Perm is: ", SDx1))


```

<p style="color:blue"> 
*Question 8:* Write code to generate $Px_{Sort}$. Compute the expected value and standard deviation of the random variable $X$. (*Hint: Check out the sort function*) **(1 marks)** </p>
```{r}
# write your code for Question 8 here

# Generate a random permutation elements from the previous saved vector Px(1)

help("sort")

Px1_Sort<-sort(Px1)

print("A sorted permutation (in ascending order) of Px1 (Px_Sort) is:")
Px1_Sort

Ex1_Sort<-sum(X*Px1_Sort)

print(paste0("The expectation value Ex of the permutation of Px_Sort is: ", Ex1_Sort))

Varx1_Sort<-sum(((X-Ex1_Sort)^2* Px1_Sort))

print(paste0("The variance value VarX of the permutation of Px_Sort is: ", Varx1_Sort))

SDx1_Sort<-sqrt(Varx1_Sort)

print(paste0("The standard deviation value SDx of the permutation of Px_Sort is: ", SDx1_Sort))

```


<p style="color:blue">
*Question 9:* Between the two design options giving key guessing probability distributions $Px_{Perm}$ (Option 1) and the distribution $Px_{Sort}$ (Option 2) which would you select as more secure and why? **(1 mark)** </p>

<textarea rows="3" cols="123">
The more secure guessing probability distribution, when taking into account Px_Perm and PX_Sort, would be Px_Sort as this sorts the distribution of guesses in ascending order from the least probable guess to the most probable guess, giving us an expectation value of 29 (in this instance), verses an expectation value of 11 for the Px_Perm distribution.
</textarea>\


You now have to design a **threshold** for the number of trials. The threshold is the trials possible before the system locks the user out. The threshold must be such that a genuine user can still try again, but a malicious attacker who is trying to guess the key has a very low chance of being successful. In fact the design criteria given to you is that the probability of an attacker being successful **must be less than $1\%$**.

<p style="color:blue">
*Question 10:* For the Option you picked in **Question 9**, describe how you would go about choosing the threshold and indicate the threshold you have chosen. **(1.5 marks)** </p>

<textarea rows="3" cols="123">
To determine the threshold value for the option picked in Question 9 (Px_Sort), the trial values within the vector are cumulatively summed (added together) then the minimum value below 1% is found.
</textarea>\

You may also want to create some code below to decide your answer.

```{r}
#Optional space for code to work out your answer

#Sum all the trials in the Px_Sort(1) vector together
cumulative_sum_of_PX_Sort <- cumsum(Px1_Sort)

print("The cumulative sum of the number of trials throughout the PX_Sort vector is as follows:")
print(cumulative_sum_of_PX_Sort)

#Find the minimum trial value within Px_Sort that ensures an attacker has less than a 1% chance of guessing the key
threshold <- which.min(cumulative_sum_of_PX_Sort < 0.01)

print(paste0("The threshold amount to avoid being locked out, while avoiding an attacker being successful in guessing the key for Px_Sort is : ", threshold))

```

***

## Randomness Testing

During the course you have studied the importance of random numbers in information security. R has a function that helps us generate random numbers. This function is called `sample()`

Run the command `example(sample)` in the code block below to look at some examples of its usage.  You should also read the help file in the pane to the right of this one.

```{r}
example(sample)
help("sample")
```

<p style="color:blue">
**Question 11:** Using what you observed in the help file, can you think of a way to use `sample()` to generate a random binary vector of length 50000? **(1 mark)** </p>

```{r}
#replace the 0 with the correct sample function variables to generate your sequence and call it s

s<-sample(c(0,1), 50000, replace=TRUE)

print("Using \`sample()\` to generate a random binary vector of length 50000:")

print(s)

length_of_s<-length(s)

# length_of_s <- length(s)

print("Confirmation that the length of the random binary value s is of length 50,000. The length of s is :")

print(length(s))


```


We can now check if $s$ satisfies some of the randomness properties that we studied in Week 4.

<p style="color:blue">
**Question 12:** The first test is the *Frequency Test*. Let us check if $s$ passes the frequency test at $5\%$ level of significance. The `which()` command helps you find the number of `0s` and number of `1s` in the sequence $s$ as shown in the code block below. **(0.5 marks)** </p>

```{r}
#length of the sequence
N<-length(s)
print(paste0("The length of the random binary sequence N is: " ,N))
  
#number of zeros   
N_0<-length(which(s==0))
print(paste0("The number of 0s in the random binary sequence N is: " ,N_0))
  
#number of 1s, adapt the above code to calculate number of 1s in p
N_1<-length(which(s==1)) #replace with formula
print(paste0("The number of 0s in the random binary sequence N is: " ,N_1))

N_total<-N_1 + N_0
print(paste0("The total sum of 0s and 1s in the random binary sequence N is: " ,N_total))

```

<p style="color:blue">
**Question 13:** Calculate $Z_f$ using this formula: $Z_f$ = $\sqrt{(N\_0 -N\_1)^2/N}$ = $| N\_0 - N\_1 | / \sqrt{N}$ **(0.5 marks)** </p>
```{r}

#Replace the 0 below to calculate Z_f from N_0 and N_1, with the formula given in the question - details are in the Week 4 course notes on randomness testing if you need more information.
Z_f<-0
Z_f<-sqrt((N_0 - N_1)^2/N)

print(paste0("The value of Z_f is:", Z_f))

print("Working out to confirm the value of Z_f is correct using each step of the above formula:")

Z_f1<-N_0 - N_1
print(paste0("The first step to find Z_f, subtracting N_1 from N_0 is: ", Z_f1))

Z_f2<-Z_f1^2
print(paste0("The second step to find Z_f, squaring the result from the above value is: ", Z_f2))

Z_f3<-Z_f2/N
print(paste0("The third step to find Z_f, dividing the result from the above with the value N is: ", Z_f3))

Z_f4<-sqrt(Z_f3)
print(paste0("The last step to find Z_f, square rooting the result from the above is: ", Z_f4))

```
Now use the code below to find the p-value for the Z_f that you calculated using the function `erfc()` is the complementary error function needed for the *Frequency Test* 
</p>

```{r}
Pvalue<-erfc(Z_f)
Pvalue
```

<p style="color:blue">
**Question 14:** Based on the P value, would the sequence $s$ pass the Frequency Test at $5\%$ level of significance? Explain why or why not. **(1 mark)** </p>

<textarea rows="4" cols="123">
With a probability value of 0.7614489, the sequence s would not pass the Frequency Test at 5% level of significance as the value obtained was approximately 76%, which is greater than the 5% for the pass. This means that as the p-value is far beyond the pass value to reject the null hypothesis that the sequence is not a random binary string (i.e. it is highly likely that the binary string is random).
</textarea>\

<p style="color:blue">
**Question 15:** 
Check whether your vector $s$ passes the runs test at $5\%$ level of significance. You can find an existing function in a package to test this for you. *Hint: look at the top of this notebook for the loaded packages as a start* Use the function you find to answer if $s$ passes or not. **(1.5 marks)** </p>

<textarea rows="3" cols="123">
The sequence passes the runs test at 5% level of significance as the p-value (0.4289) is greater than 5% (i.e. ~43%) and, therefore, the null hypothesis again cannot be rejected that the sequence is not a random binary string (i.e., again it is likely that the sequence is random).
</textarea>\

You can also use the code block below to help answer this question.

```{r}
#Optional space for code to work out your answer

RunsTest(s)


```

---
<center>**Congratulations!!! You have completed the Assignment 1C**</center>